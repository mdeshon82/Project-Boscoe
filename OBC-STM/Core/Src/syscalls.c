/**
 ******************************************************************************
 * @file      syscalls.c
 * @author    Auto-generated by STM32CubeMX (edited)
 * @brief     Minimal System calls file (cleaned)
 *
 * Note:
 *  - This file intentionally DOES NOT provide _sbrk().
 *    Ensure your project has exactly one _sbrk implementation (e.g. in sysmem.c).
 ******************************************************************************
 */

/* Includes */
#include <sys/stat.h>
#include <stdlib.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/types.h>  /* for caddr_t */
#include <stdint.h>

/* Weak hooks provided by board code to redirect I/O */
extern int __io_putchar(int ch) __attribute__((weak));
extern int __io_getchar(void) __attribute__((weak));

/* Minimal environment required by some C libraries */
static char *dummy_environ[1] = { 0 };
char **environ = dummy_environ;

/* Empty monitor handles initializer (Keil/SEGGER/etc may provide real version) */
void initialise_monitor_handles(void)
{
    /* Nothing to do by default */
}

/* Process-management stubs */
int _getpid(void)
{
    return 1;
}

int _kill(int pid, int sig)
{
    (void)pid;
    (void)sig;
    errno = EINVAL;
    return -1;
}

void _exit(int status)
{
    (void)status;
    _kill(status, -1);
    while (1) {
        /* hang */
    }
}

/* Read from low-level input (stdin)
 * Note: __io_getchar may be NULL if not implemented; return 0 on EOF in that case.
 */
__attribute__((weak))
int _read(int file, char *ptr, int len)
{
    (void)file;
    int i = 0;

    if (len <= 0 || ptr == NULL) {
        return 0;
    }

    if (__io_getchar == NULL) {
        /* No input function available — behave as EOF */
        return 0;
    }

    for (i = 0; i < len; ++i) {
        int c = __io_getchar();
        if (c < 0) {
            /* treat negative as EOF/interrupt */
            break;
        }
        ptr[i] = (char)c;
    }

    return i;
}

/* Write to low-level output (stdout/stderr)
 * Note: __io_putchar can be provided by board support to send each char to UART.
 */
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    (void)file;
    int i = 0;

    if (len <= 0 || ptr == NULL) {
        return 0;
    }

    if (__io_putchar == NULL) {
        /* No output function available */
        errno = ENOSYS;
        return -1;
    }

    for (i = 0; i < len; ++i) {
        /* write each character; ignore return value from __io_putchar */
        __io_putchar((int)ptr[i]);
    }

    return len;
}

/* File descriptor stubs */
int _close(int file)
{
    (void)file;
    return -1;
}

int _fstat(int file, struct stat *st)
{
    (void)file;
    if (st) {
        st->st_mode = S_IFCHR;
    }
    return 0;
}

int _isatty(int file)
{
    (void)file;
    return 1;
}

int _lseek(int file, int ptr, int dir)
{
    (void)file;
    (void)ptr;
    (void)dir;
    return 0;
}

int _open(char *path, int flags, ...)
{
    (void)path;
    (void)flags;
    return -1;
}

int _wait(int *status)
{
    (void)status;
    errno = ECHILD;
    return -1;
}

int _unlink(char *name)
{
    (void)name;
    errno = ENOENT;
    return -1;
}

clock_t _times(struct tms *buf)
{
    (void)buf;
    return (clock_t)-1;
}

int _stat(const char *file, struct stat *st)
{
    (void)file;
    if (st) {
        st->st_mode = S_IFCHR;
    }
    return 0;
}

int _link(char *old, char *new)
{
    (void)old;
    (void)new;
    errno = EMLINK;
    return -1;
}

int _fork(void)
{
    errno = EAGAIN;
    return -1;
}

int _execve(char *name, char **argv, char **env)
{
    (void)name;
    (void)argv;
    (void)env;
    errno = ENOMEM;
    return -1;
}

/* --------------------------------------------------------------------------
 * NOTE ABOUT _sbrk:
 * --------------------------------------------------------------------------
 * This file intentionally does NOT define _sbrk(). Your project previously had
 * a duplicate definition (one here and one in sysmem.c). Having two
 * definitions causes "multiple definition of `_sbrk`" linker errors.
 *
 * Make sure exactly one source file in your build provides _sbrk(). Common
 * places:
 *   - Core/Src/sysmem.c    <-- often provided by CubeMX
 *   - Core/Src/syscalls.c  <-- if you want the heap logic here, put it here and
 *                             remove/disable it in sysmem.c
 *
 * If you want me to put a safe _sbrk() implementation here instead, tell me
 * and I'll provide it — but first confirm you will remove the other one.
 */

/* --------------------------------------------------------------------------
 * Picolibc support section (if using picolibc)
 * -------------------------------------------------------------------------- */
#if defined(__PICOLIBC__)

#include <stdio.h>
/* Helper wrappers connecting FILE to low-level io functions */
static int starm_putc(char c, FILE *file)
{
    (void)file;
    if (__io_putchar) {
        __io_putchar((int)c);
        return (int)c;
    }
    return EOF;
}

static int starm_getc(FILE *file)
{
    (void)file;
    if (__io_getchar) {
        int c = __io_getchar();
        if (c < 0) return EOF;
        return c;
    }
    return EOF;
}

/* Use libc-provided macro if available */
#ifndef FDEV_SETUP_STREAM
/* Minimal fallback stub if FDEV_SETUP_STREAM macro is not present.
 * If compiler/libc provides FDEV_SETUP_STREAM, that should be used instead.
 */
static FILE __stdio = { 0 };
#else
static FILE __stdio = FDEV_SETUP_STREAM(starm_putc, starm_getc, NULL, _FDEV_SETUP_RW);
#endif

FILE *const stdin = &__stdio;
__strong_reference(stdin, stdout);
__strong_reference(stdin, stderr);

/* Map standard names to syscall names for picolibc */
__strong_reference(_read, read);
__strong_reference(_write, write);
__strong_reference(_times, times);
__strong_reference(_execve, execve);
__strong_reference(_fork, fork);
__strong_reference(_link, link);
__strong_reference(_unlink, unlink);
__strong_reference(_stat, stat);
__strong_reference(_wait, wait);
__strong_reference(_open, open);
__strong_reference(_close, close);
__strong_reference(_lseek, lseek);
__strong_reference(_isatty, isatty);
__strong_reference(_fstat, fstat);
__strong_reference(_exit, exit);
__strong_reference(_kill, kill);
__strong_reference(_getpid, getpid);

#endif /* __PICOLIBC__ */
